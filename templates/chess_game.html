{% extends 'base.html' %}

{% block title %}Chess Game{% endblock %}

{% block content %}
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <!-- Bootstrap for Modals (Pawn Promotion) -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

    <style>
        body {
            background-color: var(--background-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding-top: 20px; /* Reduced padding as home button is gone */
            padding-bottom: 20px; /* Reduced padding */
            box-sizing: border-box;
            overflow-y: auto; /* Allow scrolling if content exceeds viewport */
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            max-width: 90vw;
            width: 100%;
            padding: 20px;
            background-color: var(--card-bg);
            border-radius: 1rem;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            position: relative; /* For loading spinner overlay */
        }

        .scoreboard {
            display: flex;
            justify-content: space-around;
            width: 100%;
            max-width: 500px;
            padding: 15px;
            background-color: #3f51b5; /* Blue */
            color: white;
            border-radius: 0.75rem;
            font-weight: bold;
            font-size: 1.2em;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .board-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 95%; /* Adjusted to be slightly less than 100% of parent for padding */
            max-width: 600px; /* Max width for the board */
            aspect-ratio: 1 / 1; /* Keep board square */
            border: 4px solid var(--text-color);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            border-radius: 0.5rem;
            overflow: hidden; /* Ensures rounded corners */
        }

        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 100%;
            height: 100%;
        }

        .square {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3.5vw; /* Responsive font size for pieces */
            cursor: pointer;
            user-select: none; /* Prevent text selection */
            transition: background-color 0.1s ease-in-out;
            min-width: 40px; /* Ensure squares have a minimum size */
            min-height: 40px; /* Ensure squares have a minimum size */
        }

        /* Chess board colors */
        .light { background-color: #f0d9b5; color: #b58863; } /* Light wood color */
        .dark { background-color: #b58863; color: #f0d9b5; } /* Dark wood color */

        /* Highlight colors */
        .selected { background-color: #ffcc00 !important; } /* Yellow for selected piece */
        .possible-move { background-color: #88ff88 !important; } /* Green for possible moves */
        .capture-move { background-color: #ff8888 !important; } /* Red for capture moves */
        .in-check { background-color: #ff4444 !important; } /* Red for king in check */


        /* Piece styling */
        .piece {
            font-family: 'Arial Unicode MS', 'Segoe UI Symbol', 'Noto Color Emoji', sans-serif; /* Fallback for chess symbols */
            font-size: 4.5vw; /* Larger for pieces */
            line-height: 1;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        .white-piece { color: #fff; }
        .black-piece { color: #000; }

        /* Responsive font size for pieces */
        @media (min-width: 768px) {
            .square {
                font-size: 2.5vw;
            }
            .piece {
                font-size: 3.5vw;
            }
        }
        @media (min-width: 1024px) {
            .square {
                font-size: 2vw;
            }
            .piece {
                font-size: 2.5vw;
            }
        }

        .game-controls {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }
        .game-controls button {
            padding: 10px 20px;
            border-radius: 0.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .game-controls button:hover {
            transform: translateY(-2px);
        }
        .btn-reset {
            background-color: #dc3545;
            color: white;
        }
        .btn-reset:hover {
            background-color: #c82333;
        }
        .btn-back {
            background-color: #6c757d;
            color: white;
        }
        .btn-back:hover {
            background-color: #5a6268;
        }

        /* Message box for game end */
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--card-bg);
            border: 2px solid var(--primary-color);
            padding: 30px;
            border-radius: 1rem;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
            text-align: center;
            z-index: 1001;
            font-size: 1.5em;
            font-weight: bold;
            color: var(--text-color);
            display: none; /* Hidden by default */
        }
        .message-box button {
            margin-top: 20px;
            padding: 10px 25px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.2s, transform 0.2s;
        }
        .message-box button:hover {
            background-color: #368a3a;
            transform: translateY(-2px);
        }

        /* Pawn Promotion Modal */
        .promotion-modal-content {
            background-color: var(--card-bg);
            color: var(--text-color);
            border-radius: 1rem;
            border: 2px solid var(--primary-color);
        }
        .promotion-modal-header {
            border-bottom: 1px solid var(--card-border);
        }
        .promotion-option {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 15px;
            margin: 5px;
            border: 1px solid var(--card-border);
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.2s;
            font-size: 2em; /* Larger piece symbol */
            font-weight: bold;
        }
        .promotion-option:hover {
            background-color: var(--nav-link-hover-bg);
            transform: translateY(-2px);
        }
        .promotion-option .piece {
            font-size: 1.5em; /* Adjust piece size within option */
        }
    </style>
</head>
<body>
    <!-- Home Button has been removed as requested -->

    <div class="game-container">
        <h1 class="text-4xl font-extrabold text-blue-500">Chess Game</h1>

        <div class="scoreboard">
            <span id="whiteScore">White Captures: 0</span>
            <span id="blackScore">Black Captures: 0</span>
            <span id="turnIndicator">White's Turn</span>
        </div>

        <div class="board-wrapper">
            <div id="chessBoard" class="chess-board">
                <!-- Chess squares will be dynamically generated here -->
            </div>
        </div>

        <div class="game-controls">
            <button id="resetButton" class="btn-reset">Reset Game</button>
            <button id="backToLibraryButton" class="btn-back" onclick="window.location.href='{{ url_for('games_hub') }}'">Back to Library</button>
        </div>
    </div>

    <!-- Message Box for Checkmate/Stalemate -->
    <div id="messageBox" class="message-box">
        <p id="messageText"></p>
        <button id="messageBoxCloseButton">OK</button>
    </div>

    <!-- Pawn Promotion Modal -->
    <div class="modal fade" id="promotionModal" tabindex="-1" aria-labelledby="promotionModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content promotion-modal-content">
          <div class="modal-header promotion-modal-header">
            <h5 class="modal-title" id="promotionModalLabel">Pawn Promotion</h5>
          </div>
          <div class="modal-body">
            <p class="text-center text-muted">Choose a piece to promote your pawn to:</p>
            <div class="d-flex justify-content-around mt-3">
              <div class="promotion-option" data-piece="Q">
                <span class="piece white-piece">&#9813;</span> <!-- Queen -->
              </div>
              <div class="promotion-option" data-piece="R">
                <span class="piece white-piece">&#9814;</span> <!-- Rook -->
              </div>
              <div class="promotion-option" data-piece="B">
                <span class="piece white-piece">&#9815;</span> <!-- Bishop -->
              </div>
              <div class="promotion-option" data-piece="N">
                <span class="piece white-piece">&#9816;</span> <!-- Knight -->
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script type="module">
        document.addEventListener('DOMContentLoaded', function() {
            const boardElement = document.getElementById('chessBoard');
            const turnIndicator = document.getElementById('turnIndicator');
            const resetButton = document.getElementById('resetButton');
            const whiteScoreElement = document.getElementById('whiteScore');
            const blackScoreElement = document.getElementById('blackScore');
            const messageBox = document.getElementById('messageBox');
            const messageText = document.getElementById('messageText');
            const messageBoxCloseButton = document.getElementById('messageBoxCloseButton');
            const promotionModalElement = document.getElementById('promotionModal');
            const promotionModal = new bootstrap.Modal(promotionModalElement);
            const promotionOptions = document.querySelectorAll('.promotion-option');

            // Game state variables
            let board = [];
            let turn = 'w';
            let selectedSquare = null;
            let selectedPiecePos = null;
            let validMoves = [];
            let whiteCaptures = 0;
            let blackCaptures = 0;
            let gameOver = false;
            let castlingRights = { 'wK': true, 'wQ': true, 'bK': true, 'bQ': true };
            let enPassantTarget = null;
            let lastMove = null;
            let promotionPawnPos = null;
            let moveHistory = []; // To store moves for Stockfish

            // Initialize Stockfish as a Web Worker
            // Ensure the path to stockfish.js is correct. It should be in static/js/
            const stockfish = new Worker('{{ url_for("static", filename="js/stockfish.js") }}');
            let stockfishReady = false;

            stockfish.onmessage = function(event) {
                const message = event.data;
                console.log('Stockfish message:', message); // Log all messages from Stockfish
                if (message === 'readyok') {
                    stockfishReady = true;
                    console.log('Stockfish is ready.');
                    // If it's AI's turn immediately after loading (e.g., after a reset), trigger move
                    if (turn === 'b' && !gameOver) {
                        console.log('Stockfish is ready and it is Black\'s turn. Triggering AI move.');
                        setTimeout(makeAIMove, 500); // Small delay before AI moves
                    }
                } else if (message.startsWith('bestmove')) {
                    const move = message.split(' ')[1];
                    console.log('Stockfish bestmove received:', move);
                    if (move && !gameOver && turn === 'b') {
                        // Convert UCI move (e.g., 'e2e4') to board coordinates
                        const startCol = move.charCodeAt(0) - 'a'.charCodeAt(0);
                        const startRow = 8 - parseInt(move[1], 10);
                        const endCol = move.charCodeAt(2) - 'a'.charCodeAt(0);
                        const endRow = 8 - parseInt(move[3], 10);

                        // Handle promotion for Stockfish move
                        let promotionPiece = null;
                        if (move.length === 5) {
                            promotionPiece = move[4]; // e.g., 'q', 'r', 'b', 'n'
                        }

                        console.log(`AI move: from (${startRow},${startCol}) to (${endRow},${endCol})`);
                        // Directly apply the AI's move
                        applyAIMove(startRow, startCol, endRow, endCol, promotionPiece);
                    }
                }
            };

            stockfish.postMessage('uci');
            stockfish.postMessage('isready');
            stockfish.postMessage('setoption name Skill Level value 10');

            const isMultiplayerGame = false;
            const currentPlayerColor = 'w';

            const PIECES = {
                'K': '&#9812;', 'Q': '&#9813;', 'R': '&#9814;', 'B': '&#9815;', 'N': '&#9816;', 'P': '&#9817;',
                'k': '&#9818;', 'q': '&#9819;', 'r': '&#9820;', 'b': '&#9821;', 'n': '&#9822;', 'p': '&#9823;'
            };

            const INITIAL_BOARD_FEN = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';

            function updateTurnIndicator() {
                turnIndicator.textContent = (turn === 'w') ? "White's Turn" : "Black's Turn";
                turnIndicator.style.color = (turn === 'w') ? 'yellow' : 'white';
            }

            function updateScoreboard() {
                whiteScoreElement.textContent = `White Captures: ${whiteCaptures}`;
                blackScoreElement.textContent = `Black Captures: ${blackCaptures}`;
            }

            function showMessageBox(message) {
                messageText.textContent = message;
                messageBox.style.display = 'block';
            }

            function hideMessageBox() {
                messageBox.style.display = 'none';
            }

            function showPromotionModal() {
                const pieceColorClass = turn === 'w' ? 'white-piece' : 'black-piece';
                promotionOptions.forEach(option => {
                    const span = option.querySelector('.piece');
                    span.classList.remove('white-piece', 'black-piece');
                    span.classList.add(pieceColorClass);
                });
                promotionModal.show();
            }

            function hidePromotionModal() {
                promotionModal.hide();
            }

            function parseFEN(fen) {
                board = Array(8).fill(null).map(() => Array(8).fill(null));
                const parts = fen.split(' ');
                const boardString = parts[0];
                turn = parts[1];
                const castlingString = parts[2];
                castlingRights = {
                    'wK': castlingString.includes('K'),
                    'wQ': castlingString.includes('Q'),
                    'bK': castlingString.includes('k'),
                    'bQ': castlingString.includes('q')
                };
                const enPassantString = parts[3];
                if (enPassantString !== '-') {
                    const colChar = enPassantString.charCodeAt(0) - 'a'.charCodeAt(0);
                    const rowNum = parseInt(enPassantString[1], 10);
                    enPassantTarget = { row: 8 - rowNum, col: colChar };
                } else {
                    enPassantTarget = null;
                }
                let row = 0, col = 0;
                for (let i = 0; i < boardString.length; i++) {
                    const char = boardString[i];
                    if (char === '/') { row++; col = 0; }
                    else if (/\d/.test(char)) col += parseInt(char, 10);
                    else { board[row][col] = char; col++; }
                }
            }

            function renderBoard() {
                boardElement.innerHTML = '';
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const square = document.createElement('div');
                        square.classList.add('square');
                        square.classList.add((r + c) % 2 === 0 ? 'light' : 'dark');
                        square.dataset.row = r;
                        square.dataset.col = c;
                        const pieceChar = board[r][c];
                        if (pieceChar) {
                            const pieceElement = document.createElement('span');
                            pieceElement.classList.add('piece');
                            pieceElement.classList.add(pieceChar === pieceChar.toUpperCase() ? 'white-piece' : 'black-piece');
                            pieceElement.innerHTML = PIECES[pieceChar];
                            square.appendChild(pieceElement);
                        }
                        square.addEventListener('click', (event) => handleSquareClick(event, r, c)); // Pass row, col
                        boardElement.appendChild(square);
                    }
                }
                updateTurnIndicator();
                updateScoreboard();
                const kingPos = findKing(turn === 'w', board);
                if (kingPos && isKingInCheck(board, turn === 'w')) {
                    const kingSquare = boardElement.querySelector(`[data-row="${kingPos.row}"][data-col="${kingPos.col}"]`);
                    if (kingSquare) kingSquare.classList.add('in-check');
                }
            }

            function getPieceColor(pieceChar) {
                if (!pieceChar) return null;
                return pieceChar === pieceChar.toUpperCase() ? 'w' : 'b';
            }

            function isPlayersPiece(pieceChar, checkTurn) {
                return (checkTurn === 'w' && pieceChar === pieceChar.toUpperCase()) ||
                       (checkTurn === 'b' && pieceChar === pieceChar.toLowerCase());
            }

            function isOpponentPiece(targetPieceChar, isMovingPieceWhite) {
                return (isMovingPieceWhite && targetPieceChar === targetPieceChar.toLowerCase()) ||
                       (!isMovingPieceWhite && targetPieceChar === targetPieceChar.toUpperCase());
            }

            function selectPiece(squareElement, row, col) {
                selectedSquare = squareElement;
                selectedPiecePos = { row, col };
                selectedSquare.classList.add('selected');
                highlightPossibleMoves(row, col);
            }

            function highlightPossibleMoves(row, col) {
                validMoves = getLegalMoves(row, col);
                validMoves.forEach(move => {
                    const targetSquare = boardElement.querySelector(`[data-row="${move[0]}"][data-col="${move[1]}"]`);
                    if (targetSquare) {
                        if (board[move[0]][move[1]]) targetSquare.classList.add('capture-move');
                        else targetSquare.classList.add('possible-move');
                    }
                });
            }

            function getPseudoLegalMoves(row, col, currentBoard, currentTurn) {
                const piece = currentBoard[row][col];
                if (!piece) return [];
                const isWhite = piece === piece.toUpperCase();
                let moves = [];
                switch (piece.toLowerCase()) {
                    case 'p': moves = getPawnPseudoLegalMoves(row, col, isWhite, currentBoard); break;
                    case 'r': moves = getRookPseudoLegalMoves(row, col, isWhite, currentBoard); break;
                    case 'n': moves = getKnightPseudoLegalMoves(row, col, isWhite, currentBoard); break;
                    case 'b': moves = getBishopPseudoLegalMoves(row, col, isWhite, currentBoard); break;
                    case 'q': moves = getQueenPseudoLegalMoves(row, col, isWhite, currentBoard); break;
                    case 'k': moves = getKingPseudoLegalMoves(row, col, isWhite, currentBoard); break;
                }
                return moves;
            }

            function getPawnPseudoLegalMoves(row, col, isWhite, currentBoard) {
                const moves = [];
                const direction = isWhite ? -1 : 1;
                const startRow = isWhite ? 6 : 1;
                if (isValidBoardPos(row + direction, col) && !currentBoard[row + direction][col]) moves.push([row + direction, col]);
                if (row === startRow && isValidBoardPos(row + 2 * direction, col) && !currentBoard[row + 2 * direction][col] && !currentBoard[row + direction][col]) moves.push([row + 2 * direction, col]);
                const captureCols = [col - 1, col + 1];
                captureCols.forEach(c => {
                    if (isValidBoardPos(row + direction, c)) {
                        const targetPiece = currentBoard[row + direction][c];
                        if (targetPiece && isOpponentPiece(targetPiece, isWhite)) moves.push([row + direction, c]);
                    }
                });
                if (enPassantTarget) {
                    const enPassantPawnRow = isWhite ? 3 : 4;
                    if (row === enPassantPawnRow && enPassantTarget.row === row + direction && Math.abs(enPassantTarget.col - col) === 1) {
                        if (lastMove && lastMove.piece.toLowerCase() === 'p' && Math.abs(lastMove.startRow - lastMove.endRow) === 2 && lastMove.endCol === enPassantTarget.col && lastMove.endRow === row) {
                            moves.push([enPassantTarget.row, enPassantTarget.col, 'enPassant']);
                        }
                    }
                }
                return moves;
            }

            function getRookPseudoLegalMoves(row, col, isWhite, currentBoard) {
                const moves = [];
                const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                directions.forEach(dir => {
                    for (let i = 1; i < 8; i++) {
                        const newRow = row + i * dir[0];
                        const newCol = col + i * dir[1];
                        if (!isValidBoardPos(newRow, newCol)) break;
                        const targetPiece = currentBoard[newRow][newCol];
                        if (targetPiece) {
                            if (isOpponentPiece(targetPiece, isWhite)) moves.push([newRow, newCol]);
                            break;
                        }
                        moves.push([newRow, newCol]);
                    }
                });
                return moves;
            }

            function getKnightPseudoLegalMoves(row, col, isWhite, currentBoard) {
                const moves = [];
                const knightOffsets = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];
                knightOffsets.forEach(offset => {
                    const newRow = row + offset[0];
                    const newCol = col + offset[1];
                    if (isValidBoardPos(newRow, newCol)) {
                        const targetPiece = currentBoard[newRow][newCol];
                        if (!targetPiece || isOpponentPiece(targetPiece, isWhite)) moves.push([newRow, newCol]);
                    }
                });
                return moves;
            }

            function getBishopPseudoLegalMoves(row, col, isWhite, currentBoard) {
                const moves = [];
                const directions = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
                directions.forEach(dir => {
                    for (let i = 1; i < 8; i++) {
                        const newRow = row + i * dir[0];
                        const newCol = col + i * dir[1];
                        if (!isValidBoardPos(newRow, newCol)) break;
                        const targetPiece = currentBoard[newRow][newCol];
                        if (targetPiece) {
                            if (isOpponentPiece(targetPiece, isWhite)) moves.push([newRow, newCol]);
                            break;
                        }
                        moves.push([newRow, newCol]);
                    }
                });
                return moves;
            }

            function getQueenPseudoLegalMoves(row, col, isWhite, currentBoard) {
                return getRookPseudoLegalMoves(row, col, isWhite, currentBoard).concat(getBishopPseudoLegalMoves(row, col, isWhite, currentBoard));
            }

            function getKingPseudoLegalMoves(row, col, isWhite, currentBoard) {
                const moves = [];
                const kingOffsets = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
                const currentKingRow = row;
                kingOffsets.forEach(offset => {
                    const newRow = row + offset[0];
                    const newCol = col + offset[1];
                    if (isValidBoardPos(newRow, newCol)) {
                        const targetPiece = currentBoard[newRow][newCol];
                        if (!targetPiece || isOpponentPiece(targetPiece, isWhite)) moves.push([newRow, newCol]);
                    }
                });
                if (!isKingInCheck(currentBoard, isWhite)) {
                    if (isWhite && castlingRights.wK && currentBoard[currentKingRow][5] === null && currentBoard[currentKingRow][6] === null && currentBoard[currentKingRow][7] === 'R' && !isSquareAttacked(currentKingRow, 5, !isWhite, currentBoard) && !isSquareAttacked(currentKingRow, 6, !isWhite, currentBoard)) {
                        moves.push([currentKingRow, 6, 'castlingK']);
                    } else if (!isWhite && castlingRights.bK && currentBoard[currentKingRow][5] === null && currentBoard[currentKingRow][6] === null && currentBoard[currentKingRow][7] === 'r' && !isSquareAttacked(currentKingRow, 5, !isWhite, currentBoard) && !isSquareAttacked(currentKingRow, 6, !isWhite, currentBoard)) {
                        moves.push([currentKingRow, 6, 'castlingK']);
                    }
                    if (isWhite && castlingRights.wQ && currentBoard[currentKingRow][1] === null && currentBoard[currentKingRow][2] === null && currentBoard[currentKingRow][3] === null && currentBoard[currentKingRow][0] === 'R' && !isSquareAttacked(currentKingRow, 2, !isWhite, currentBoard) && !isSquareAttacked(currentKingRow, 3, !isWhite, currentBoard)) {
                        moves.push([currentKingRow, 2, 'castlingQ']);
                    } else if (!isWhite && castlingRights.bQ && currentBoard[currentKingRow][1] === null && currentBoard[currentKingRow][2] === null && currentBoard[currentKingRow][3] === null && currentBoard[currentKingRow][0] === 'r' && !isSquareAttacked(currentKingRow, 2, !isWhite, currentBoard) && !isSquareAttacked(currentKingRow, 3, !isWhite, currentBoard)) {
                        moves.push([currentKingRow, 2, 'castlingQ']);
                    }
                }
                return moves;
            }

            function isValidBoardPos(row, col) {
                return row >= 0 && row < 8 && col >= 0 && col < 8;
            }

            function findKing(isWhite, currentBoard) {
                const kingChar = isWhite ? 'K' : 'k';
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        if (currentBoard[r][c] === kingChar) return { row: r, col: c };
                    }
                }
                return null;
            }

            function isSquareAttacked(targetRow, targetCol, checkByWhitePieces, currentBoard) {
                const attackingColor = checkByWhitePieces ? 'w' : 'b';
                function checkSlidingAttack(r, c, dRow, dCol, pieceTypes) {
                    for (let i = 1; i < 8; i++) {
                        const currR = r + i * dRow;
                        const currC = c + i * dCol;
                        if (!isValidBoardPos(currR, currC)) break;
                        const piece = currentBoard[currR][currC];
                        if (piece) {
                            if (isPlayersPiece(piece, attackingColor) && pieceTypes.includes(piece.toLowerCase())) return true;
                            break;
                        }
                    }
                    return false;
                }
                const pawnDirection = attackingColor === 'w' ? -1 : 1;
                const pawnAttackOffsets = [[pawnDirection, -1], [pawnDirection, 1]];
                for (const offset of pawnAttackOffsets) {
                    const r = targetRow + offset[0];
                    const c = targetCol + offset[1];
                    if (isValidBoardPos(r, c)) {
                        const piece = currentBoard[r][c];
                        if (piece && piece.toLowerCase() === 'p' && isPlayersPiece(piece, attackingColor)) return true;
                    }
                }
                const knightOffsets = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];
                for (const offset of knightOffsets) {
                    const r = targetRow + offset[0];
                    const c = targetCol + offset[1];
                    if (isValidBoardPos(r, c)) {
                        const piece = currentBoard[r][c];
                        if (piece && piece.toLowerCase() === 'n' && isPlayersPiece(piece, attackingColor)) return true;
                    }
                }
                const rookQueenDirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                for (const dir of rookQueenDirs) {
                    if (checkSlidingAttack(targetRow, targetCol, dir[0], dir[1], ['r', 'q'])) return true;
                }
                const bishopQueenDirs = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
                for (const dir of bishopQueenDirs) {
                    if (checkSlidingAttack(targetRow, targetCol, dir[0], dir[1], ['b', 'q'])) return true;
                }
                const kingOffsets = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
                for (const offset of kingOffsets) {
                    const r = targetRow + offset[0];
                    const c = targetCol + offset[1];
                    if (isValidBoardPos(r, c)) {
                        const piece = currentBoard[r][c];
                        if (piece && piece.toLowerCase() === 'k' && isPlayersPiece(piece, attackingColor)) return true;
                    }
                }
                return false;
            }

            function isKingInCheck(currentBoard, isWhiteKing) {
                const kingPos = findKing(isWhiteKing, currentBoard);
                if (!kingPos) return false;
                return isSquareAttacked(kingPos.row, kingPos.col, !isWhiteKing, currentBoard);
            }

            function getLegalMoves(startRow, startCol) {
                const pseudoLegalMoves = getPseudoLegalMoves(startRow, startCol, board, turn);
                const legalMoves = [];
                const originalPiece = board[startRow][startCol];
                const isMovingPieceWhite = getPieceColor(originalPiece) === 'w';
                const originalBoard = JSON.parse(JSON.stringify(board));
                const originalCastlingRights = { ...castlingRights };
                const originalEnPassantTarget = enPassantTarget;
                const originalLastMove = lastMove;
                for (const move of pseudoLegalMoves) {
                    const endRow = move[0];
                    const endCol = move[1];
                    const specialMoveType = move[2];
                    const simulatedBoard = JSON.parse(JSON.stringify(originalBoard));
                    simulatedBoard[endRow][endCol] = simulatedBoard[startRow][startCol];
                    simulatedBoard[startRow][startCol] = null;
                    if (specialMoveType === 'castlingK') {
                        const rookChar = isMovingPieceWhite ? 'R' : 'r';
                        simulatedBoard[startRow][5] = rookChar;
                        simulatedBoard[startRow][7] = null;
                    } else if (specialMoveType === 'castlingQ') {
                        const rookChar = isMovingPieceWhite ? 'R' : 'r';
                        simulatedBoard[startRow][3] = rookChar;
                        simulatedBoard[startRow][0] = null;
                    } else if (specialMoveType === 'enPassant') {
                        const capturedPawnRow = isMovingPieceWhite ? endRow + 1 : endRow - 1;
                        simulatedBoard[capturedPawnRow][endCol] = null;
                    }
                    const kingInCheckAfterMove = isKingInCheck(simulatedBoard, isMovingPieceWhite);
                    if (!kingInCheckAfterMove) legalMoves.push(move);
                }
                return legalMoves;
            }

            function checkGameEnd(currentBoard, currentTurn) {
                const currentPlayerHasLegalMoves = getAllLegalMovesForPlayer(currentBoard, currentTurn).length > 0;
                const kingInCheck = isKingInCheck(currentBoard, currentTurn === 'w');
                if (!currentPlayerHasLegalMoves) {
                    gameOver = true;
                    if (kingInCheck) {
                        const winner = (currentTurn === 'w') ? 'Black' : 'White';
                        showMessageBox(`${winner} wins by Checkmate!`);
                    } else {
                        showMessageBox("Stalemate! It's a draw.");
                    }
                }
            }

            function getAllLegalMovesForPlayer(currentBoard, playerTurn) {
                const allMoves = [];
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = currentBoard[r][c];
                        if (piece && isPlayersPiece(piece, playerTurn)) {
                            allMoves.push(...getLegalMoves(r, c));
                        }
                    }
                }
                return allMoves;
            }

            promotionOptions.forEach(option => {
                option.addEventListener('click', function() {
                    const promotedTo = this.dataset.piece;
                    promotePawn(promotedTo);
                    hidePromotionModal();
                    // After promotion, check game end and trigger AI if it's their turn
                    checkGameEnd(board, turn);
                    if (turn === 'b' && !gameOver) {
                        console.log('Pawn promoted, now triggering AI move.');
                        setTimeout(makeAIMove, 500);
                    }
                });
            });

            function promotePawn(promotedToPiece) {
                if (!promotionPawnPos) return;

                const { row, col } = promotionPawnPos;
                const newPieceChar = turn === 'w' ? promotedToPiece.toUpperCase() : promotedToPiece.toLowerCase();
                board[row][col] = newPieceChar;
                promotionPawnPos = null;
                renderBoard();
            }

            function resetGameLocalState() {
                parseFEN(INITIAL_BOARD_FEN);
                selectedSquare = null;
                selectedPiecePos = null;
                validMoves = [];
                whiteCaptures = 0;
                blackCaptures = 0;
                gameOver = false;
                castlingRights = { 'wK': true, 'wQ': true, 'bK': true, 'bQ': true };
                enPassantTarget = null;
                lastMove = null;
                moveHistory = []; // Clear move history
                hideMessageBox();
                hidePromotionModal();
                renderBoard();
                // Reset Stockfish engine
                stockfish.postMessage('ucinewgame');
                stockfish.postMessage('isready');
            }

            function resetGame() {
                resetGameLocalState();
            }

            // Event listener for reset button
            resetButton.addEventListener('click', resetGame);
            messageBoxCloseButton.addEventListener('click', hideMessageBox);

            // Initial game setup
            resetGame(); // Call reset to set up the initial board and state
        });
    </script>
{% endblock %}
